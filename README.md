# AWS-Certified-Solutions-Architect-Professional-02

2025-01-01

<img width="1451" alt="image" src="https://github.com/user-attachments/assets/b0cce13b-b72e-45e5-bed0-62f2b76f99a2" />
<img width="762" alt="image" src="https://github.com/user-attachments/assets/00bde9bb-2cfa-48e0-89b7-1ea54cb06220" />



<img width="1434" alt="image" src="https://github.com/user-attachments/assets/27210dac-6b7f-45b7-a54f-642eecd99620" />
<img width="767" alt="image" src="https://github.com/user-attachments/assets/d4162330-7844-41ef-9dd4-84be5b3a21bb" />



<img width="1453" alt="image" src="https://github.com/user-attachments/assets/366a3064-dc3e-439d-9a6d-60846033d1fc" />
AB or AD 



<img width="1122" alt="image" src="https://github.com/user-attachments/assets/38c0451d-2639-4b03-93f0-7900d28e27b5" />


<img width="1110" alt="image" src="https://github.com/user-attachments/assets/88609557-ec86-4e20-ac61-c6c3599c91b0" />


<img width="1118" alt="image" src="https://github.com/user-attachments/assets/4fa30a33-186d-43d2-8e34-76f84a06e381" />
![image](https://github.com/user-attachments/assets/12b17d87-d63a-4be5-b402-884dad07da9e)
<img width="711" alt="image" src="https://github.com/user-attachments/assets/037c487a-ad69-4565-a262-a6bfd9031b4d" />


<img width="1152" alt="image" src="https://github.com/user-attachments/assets/837d4f40-a692-4449-b330-2f0ee6a18ac0" />


<img width="1461" alt="image" src="https://github.com/user-attachments/assets/4facaf7f-aa26-47f9-ad55-d0910c209308" />
ACE 

<img width="1463" alt="image" src="https://github.com/user-attachments/assets/00923175-e221-4eb0-b05b-6d8082606d56" />


<img width="1444" alt="image" src="https://github.com/user-attachments/assets/e314bed1-31ac-445f-abe3-33571dedf75f" />




<img width="1123" alt="image" src="https://github.com/user-attachments/assets/95c26bf2-98ea-406f-9f31-67bf9a268730" />

<img width="1436" alt="image" src="https://github.com/user-attachments/assets/f268abed-be03-4986-ae11-ec07e82a481e" />


<img width="1462" alt="image" src="https://github.com/user-attachments/assets/6ce9a4cd-26db-48db-9439-458396d932f8" />

<img width="1142" alt="image" src="https://github.com/user-attachments/assets/ab255c77-a3b3-48c7-bc26-6223adfa695b" />
ADE or ABE 


<img width="1113" alt="image" src="https://github.com/user-attachments/assets/405906f5-0c25-40e7-a035-60bf88af7c41" />
AAAAAAAAAA or CCCCCCCCCCC



<img width="1128" alt="image" src="https://github.com/user-attachments/assets/95aba24c-32cb-4e74-9561-733859e5677a" />


<img width="1156" alt="image" src="https://github.com/user-attachments/assets/337d0ead-128c-4f21-91c0-e2490968b611" />


<img width="1441" alt="image" src="https://github.com/user-attachments/assets/f0accfcd-aa30-458f-b669-c28254e48e7c" />
<img width="848" alt="image" src="https://github.com/user-attachments/assets/edf6d61f-a653-4918-ac05-5320887ce4b6" />


<img width="1123" alt="image" src="https://github.com/user-attachments/assets/f7373e2a-b30a-4a76-b81b-cd05ae1fd05f" />




<img width="1124" alt="image" src="https://github.com/user-attachments/assets/fb42aeaf-cf3c-4754-9be7-c4aaab1f712f" />



<img width="1125" alt="image" src="https://github.com/user-attachments/assets/a27676f9-146e-4c9d-ba80-f2b411847aca" />
<img width="624" alt="image" src="https://github.com/user-attachments/assets/751fa0d5-4d16-4e8c-bfe2-5b1dac308bf6" />


<img width="1160" alt="image" src="https://github.com/user-attachments/assets/b1aa7a7c-4341-47ba-8a41-c8c58a6963f2" />
<img width="647" alt="image" src="https://github.com/user-attachments/assets/afff8cfc-7b53-4068-bbae-e54a5e9bd958" />


2024-12-31

<img width="1119" alt="image" src="https://github.com/user-attachments/assets/b9195ce3-3f7b-426a-81e0-1f6ad8ed8ac4" />


<img width="1140" alt="image" src="https://github.com/user-attachments/assets/36126690-1122-4e07-92f6-f8e531bcc81a" />
maybe BE ?


<img width="1134" alt="image" src="https://github.com/user-attachments/assets/94252c1c-d775-4594-877b-3c8db2fa5d20" />
<img width="696" alt="image" src="https://github.com/user-attachments/assets/7380d573-3684-413a-ab79-1800c20e2373" />



<img width="1127" alt="image" src="https://github.com/user-attachments/assets/b7843112-ab2e-43a1-85d6-4687a09250f5" />


<img width="1130" alt="image" src="https://github.com/user-attachments/assets/ef59892f-95f4-407b-8e4b-5802c72a8224" />
![image](https://github.com/user-attachments/assets/2e26ce05-854f-41e6-a888-1651edbefbc4)


<img width="1126" alt="image" src="https://github.com/user-attachments/assets/28cad676-837b-4b21-b08f-4d87b903cbe2" />
CCCCCCC or AAAAAAAA (chatgpt)



<img width="1119" alt="image" src="https://github.com/user-attachments/assets/f3965b3d-a0c2-4c90-931d-2a0858f3d826" />
<img width="662" alt="image" src="https://github.com/user-attachments/assets/264372b2-8185-41d1-af53-df446dee9e8c" />



<img width="1126" alt="image" src="https://github.com/user-attachments/assets/15ce9574-e628-42f4-8afe-680d26c50c91" />



<img width="1113" alt="image" src="https://github.com/user-attachments/assets/fb8198cb-3cde-4e07-b4db-ec258ddf22a4" />
BEF or AEF 


<img width="1443" alt="image" src="https://github.com/user-attachments/assets/92cf1c4b-0ca0-41c4-83ca-4629073d17c2" />
B 
<img width="832" alt="image" src="https://github.com/user-attachments/assets/c95f4717-1ed6-4918-a892-18d7ddbb5c54" />


<img width="1124" alt="image" src="https://github.com/user-attachments/assets/a7365ba6-cda9-4947-9df0-e4248f9786a0" />




<img width="1141" alt="image" src="https://github.com/user-attachments/assets/31d39a19-bb77-4a58-a16f-02591324dedb" />
<img width="733" alt="image" src="https://github.com/user-attachments/assets/018fa6c9-8faa-4332-9ebc-af1b9045fd21" />


<img width="1117" alt="image" src="https://github.com/user-attachments/assets/d42d7ed2-9df3-4c5d-8d62-abd25b693197" />
<img width="707" alt="image" src="https://github.com/user-attachments/assets/4851a1e7-67a2-4838-bf3d-b07c30f79f74" />


<img width="1145" alt="image" src="https://github.com/user-attachments/assets/c98edcaf-b218-460a-b85d-2a2c23db2268" />
<img width="735" alt="image" src="https://github.com/user-attachments/assets/383984d9-f0b4-4c65-9e0d-70adb43e8aff" />
<img width="637" alt="image" src="https://github.com/user-attachments/assets/9255cbb3-9eec-4c08-849a-318c06c8d8ff" />


<img width="1124" alt="image" src="https://github.com/user-attachments/assets/277d6593-8116-4d82-b442-46b8d5af3959" />
<img width="768" alt="image" src="https://github.com/user-attachments/assets/c7d74b07-b5e3-4497-a6cd-60095fd57909" />
<img width="613" alt="image" src="https://github.com/user-attachments/assets/fa598c4b-0253-4fb0-963f-8809d6849512" />



<img width="1126" alt="image" src="https://github.com/user-attachments/assets/620fdc44-c796-4fea-a430-9c5d99ba646e" />
<img width="709" alt="image" src="https://github.com/user-attachments/assets/febd9231-2e8e-4d12-a1f1-7e98f3bd605a" />
<img width="669" alt="image" src="https://github.com/user-attachments/assets/bb2e50ad-cdb3-4d46-aea3-6c3f4f68a421" />



<img width="1115" alt="image" src="https://github.com/user-attachments/assets/ebdca573-cf40-4135-a6dc-908194f33a97" />
<img width="779" alt="image" src="https://github.com/user-attachments/assets/23873849-0fd0-4692-a184-3462872d9505" />
<img width="699" alt="image" src="https://github.com/user-attachments/assets/6ffe0d5a-c6d1-45a2-803c-22a6ff0c440e" />


<img width="1168" alt="image" src="https://github.com/user-attachments/assets/87d2013f-693b-4d4d-b5ff-c7476cde110a" />






<img width="1456" alt="image" src="https://github.com/user-attachments/assets/0640b427-6373-479b-9287-56698e477ec7" />
CE

<img width="1442" alt="image" src="https://github.com/user-attachments/assets/9dacdc7c-0a1a-46ec-ad02-7367b72133cc" />
????????

<img width="1115" alt="image" src="https://github.com/user-attachments/assets/481deab2-a3bd-4ff3-becd-1631332c2480" />

<img width="1120" alt="image" src="https://github.com/user-attachments/assets/341fb354-5b01-416c-aaa8-b23b1dd98a3e" />





![image](https://user-images.githubusercontent.com/36766101/204118816-da3ef40b-633b-4a31-aed0-79b2e052e0ad.png)

Amazon SNS message deliveries to AWS Lambda have crossed the account concurrency quota for Lambda, so the team needs to contact AWS support to raise the account limit
Amazon Simple Notification Service (SNS) is a highly available, durable, secure, fully managed pub/sub messaging service that enables you to decouple microservices, distributed systems, and serverless applications.
AWS Lambda currently supports 1000 concurrent executions per AWS account per region. If your Amazon SNS message deliveries to AWS Lambda contribute to crossing these concurrency quotas, your Amazon SNS message deliveries will be throttled. You need to contact AWS support to raise the account limit.
![image](https://user-images.githubusercontent.com/36766101/204115857-d0d17f06-2889-4fad-b47d-5fee86c1e5e6.png)



![image](https://user-images.githubusercontent.com/36766101/204118709-cf8abdee-d158-4d2f-b118-d590e72d82c3.png)

AWS DataSync is an online data transfer service that simplifies, automates, and accelerates copying large amounts of data to and from AWS storage services over the internet or AWS Direct Connect.
AWS DataSync fully automates and accelerates moving large active datasets to AWS, up to 10 times faster than command-line tools. It is natively integrated with Amazon S3, Amazon EFS, Amazon FSx for Windows File Server, Amazon CloudWatch, and AWS CloudTrail, which provides seamless and secure access to your storage services, as well as detailed monitoring of the transfer.
DataSync uses a purpose-built network protocol and scale-out architecture to transfer data. A single DataSync agent is capable of saturating a 10 Gbps network link. DataSync fully automates the data transfer. It comes with retry and network resiliency mechanisms, network optimizations, built-in task scheduling, monitoring via the DataSync API and Console, and CloudWatch metrics, events, and logs that provide granular visibility into the transfer process. DataSync performs data integrity verification both during the transfer and at the end of the transfer.
![image](https://user-images.githubusercontent.com/36766101/204115843-6ef38b3a-5005-4f22-bdd0-0f8e7175adf7.png)


![image](https://user-images.githubusercontent.com/36766101/204118702-5c50534d-0c67-4df9-9bb8-bcf42f7622c6.png)

AWS Lambda lets you run code without provisioning or managing servers. You pay only for the compute time you consume. Amazon Simple Queue Service (SQS) is a fully managed message queuing service that enables you to decouple and scale microservices, distributed systems, and serverless applications. SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering, and at-least-once delivery. SQS FIFO queues are designed to guarantee that messages are processed exactly once, in the exact order that they are sent.
You can use an AWS Lambda function to process messages in an Amazon Simple Queue Service (Amazon SQS) queue. Lambda event source mappings support standard queues and first-in, first-out (FIFO) queues. With Amazon SQS, you can offload tasks from one component of your application by sending them to a queue and processing them asynchronously.

![image](https://user-images.githubusercontent.com/36766101/204118720-ddde2015-5d6b-4ad3-88e2-505e12dcddc6.png)

A VPC endpoint enables you to privately connect your VPC to supported AWS services and VPC endpoint services powered by AWS PrivateLink without requiring an internet gateway, NAT device, VPN connection, or AWS Direct Connect connection. Instances in your VPC do not require public IP addresses to communicate with resources in the service. Traffic between your VPC and the other service does not leave the Amazon network.
A gateway endpoint is a gateway that you specify as a target for a route in your route table for traffic destined to a supported AWS service. One of the ways of letting EC2 instances running in private subnets of a VPC access S3 based resources is by setting up NAT instances in a public subnet and then access those S3 based resources. However, there is a more efficient and secure way. The EC2 instances running in private subnets of a VPC can control access to S3 buckets, objects, and API functions that are in the same Region as the VPC by using the S3 gateway endpoints.

You can further use an S3 bucket policy to indicate which VPCs and which VPC Endpoints have access to your S3 buckets.
![image](https://user-images.githubusercontent.com/36766101/204116046-d66939fd-35b0-4c93-8d70-6a7a3eaeef3d.png)


![image](https://user-images.githubusercontent.com/36766101/204118846-16ce4011-6c9e-4268-8d71-8e3959080491.png)

Amazon Kinesis Data Firehose is the easiest way to reliably load streaming data into data lakes, data stores, and analytics tools. It is a fully managed service that automatically scales to match the throughput of your data and requires no ongoing administration. It can also batch, compress, transform, and encrypt the data before loading it, minimizing the amount of storage used at the destination and increasing security.
When a Kinesis data stream is configured as the source of a Firehose delivery stream, Firehose’s PutRecord and PutRecordBatch operations are disabled and Kinesis Agent cannot write to Firehose delivery stream directly. Data needs to be added to the Kinesis data stream through the Kinesis Data Streams PutRecord and PutRecords operations instead. Therefore, this option is correct.
![image](https://user-images.githubusercontent.com/36766101/204116205-7c8952a0-1af8-4b93-abcc-f453d9c60502.png)



![image](https://user-images.githubusercontent.com/36766101/204118730-fdc67b0b-6b33-457e-8f49-b4c2b1cb7c5d.png)

Process and analyze the Amazon CloudWatch Logs for Lambda function to determine processing times for requested images at pre-configured intervals
To help you troubleshoot failures in a function, the Lambda service logs all requests handled by a Lambda function and also automatically stores logs generated by your code through Amazon CloudWatch Logs. You can insert logging statements into your code to determine processing times for requested images. These logs can then be processed at certain pre-configured intervals for further analysis.

Process and analyze the AWS X-Ray traces and analyze HTTP methods to determine the root cause of the HTTP errors
You can use AWS X-Ray to visualize the components of your application, identify performance bottlenecks such as the one described in the use-case for processing images and troubleshoot those requests that resulted in an error. Your Lambda functions send trace data to X-Ray, and X-Ray processes the data to generate a service map and searchable trace summaries.







Set up Systems Manager Agent on all instances to manage patching. Test patches in pre-production and then deploy as a maintenance window task with the appropriate approval
Apply patch baselines using the AWS-RunPatchBaseline SSM document

Systems Manager is an AWS service that you can use to view and control your infrastructure on AWS. Using the Systems Manager console, you can view operational data from multiple AWS services and automate operational tasks across your AWS resources. Systems Manager helps you maintain security and compliance by scanning your managed instances and reporting on (or taking corrective action on) any policy violations it detects. AWS Systems Manager Agent (SSM Agent) is Amazon software that can be installed and configured on an EC2 instance, an on-premises server, or a virtual machine (VM). SSM Agent makes it possible for Systems Manager to update, manage, and configure these resources.

You can use Patch Manager to apply patches for both operating systems and applications. (On Windows Server, application support is limited to updates for Microsoft applications). Patch Manager uses patch baselines, which include rules for auto-approving patches within days of their release, as well as a list of approved and rejected patches. You can install patches individually or to large groups of instances by using Amazon EC2 tags.
For the given use-case, you can install patches on a regular basis by scheduling patching to run as a Systems Manager maintenance window task.
Systems Manager supports an SSM document for Patch Manager, AWS-RunPatchBaseline, which performs patching operations on instances for both security-related and other types of updates. When the document is run, it uses the patch baseline currently specified as the "default" for an operating system type.


![image](https://user-images.githubusercontent.com/36766101/204118742-05c851bc-ddee-4f0d-92a1-01d0b916858d.png)


Configure SAML-based authentication tied to an IAM role that has the PowerUserAccess managed policy attached to it. Attach a customer-managed policy that denies access to RDS in any AWS Region except us-east-1. (PowerUserAccess = AdministrativeAccess - IAM)
![image](https://user-images.githubusercontent.com/36766101/204118505-63ad7539-514a-417c-8544-354ca42e96cf.png)

Security Assertion Markup Language 2.0 (SAML) is an open federation standard that allows an identity provider (IdP) to authenticate users and pass identity and security information about them to a service provider which is an AWS application or service for the current use-case. With SAML, you can enable a single sign-on experience for your users across many SAML-enabled applications and services. Users authenticate with the IdP once using a single set of credentials, and then get access to multiple applications and services without additional sign-ins.

For the given scenario, the company wants to control access to on-premises as well as AWS Cloud resources (specifically via the AWS Management Console) using Active Directory, so it should use SAML 2.0 federated users to access the AWS Management Console. You also create an IAM role with a trust policy that sets the SAML provider as the principal, which establishes a trust relationship between your organization and AWS. The role's permission policy establishes what users from your organization are allowed to do in AWS. In this case, the role will have a PowerUserAccess managed policy attached. As the PowerUserAccess managed policy will allow the developers to create RDS instances in any Region, therefore, you also need to attach a customer-managed policy that denies access to RDS in any AWS Region except us-east-1.


![image](https://user-images.githubusercontent.com/36766101/204118746-622c84c8-2105-43de-a528-3c95c646f89e.png)


Use EFS as the data tier of the storage layer

Amazon Elastic File System (Amazon EFS) provides a simple, scalable, fully managed elastic NFS file system for use with AWS Cloud services and on-premises resources.

Amazon EFS is a Regional service storing data within and across multiple Availability Zones (AZs) for high availability and durability. Amazon EC2 instances can access your file system across AZs, Regions, and VPCs, while on-premises servers can access using AWS Direct Connect or AWS VPN. You can connect to Amazon EFS file systems from EC2 instances in other AWS Regions using an inter-Region VPC peering connection, and from on-premises servers using an AWS VPN connection. EFS is also POSIX compliant and can be shared across many systems, so it fits the given use-case.

Use EC2 Instance Store as the service tier of the storage layer
An instance store (also known as ephemeral storage) provides temporary block-level storage for your instance. This storage is located on disks that are physically attached to the host computer. Instance store is ideal for the temporary storage of information that changes frequently such as buffers, caches, scratch data, and other temporary content, or for data that is replicated across a fleet of instances, such as a load-balanced pool of web servers. Instance store volumes are included as part of the instance's usage cost.

As Instance Store based volumes provide high random I/O performance at low cost (as the storage is part of the instance's usage cost) and the fault-tolerant architecture can adjust for the loss of any instance, therefore you should use Instance Store based EC2 instances for this use-case.


![image](https://user-images.githubusercontent.com/36766101/204118823-ee1cca41-713b-4820-860e-1a57efb7f212.png)


If a user or role has an IAM permission policy that grants access to an action that is either not allowed or explicitly denied by the applicable SCPs, the user or role can't perform that action.
Service control policies (SCPs) are one type of policy that can be used to manage your organization. SCPs offer central control over the maximum available permissions for all accounts in your organization, allowing you to ensure your accounts stay within your organization’s access control guidelines.


SCPs affect all users and roles in attached accounts, including the root user

SCPs do not affect service-linked role




![image](https://user-images.githubusercontent.com/36766101/204159843-3dc2412f-e8f0-4d90-b0d0-c190ae78f74f.png)
AWS Direct Connect is a cloud service solution that makes it easy to establish a dedicated network connection from your premises to AWS. AWS Direct Connect lets you establish a dedicated network connection between your network and one of the AWS Direct Connect locations.

With AWS Direct Connect plus VPN, you can combine one or more AWS Direct Connect dedicated network connections with the Amazon VPC VPN. This combination provides an IPsec-encrypted private connection that also reduces network costs, increases bandwidth throughput, and provides a more consistent network experience than internet-based VPN connections. This solution combines the AWS managed benefits of the VPN solution with low latency, increased bandwidth, more consistent benefits of the AWS Direct Connect solution, and an end-to-end, secure IPsec connection. Therefore, AWS Direct Connect plus VPN is the correct solution for this use-case.



![image](https://user-images.githubusercontent.com/36766101/204159952-fff6c9a0-76b2-44a0-abb8-5750582029d8.png)
The AWS Snowball Edge is a type of Snowball device with on-board storage and compute power for select AWS capabilities. Each Snowball Edge device can transport data at speeds faster than the internet. This transport is done by shipping the data in the appliances through a Regional carrier. The appliances are rugged shipping containers, complete with E Ink shipping labels. Snowball Edge devices have three options for device configurations – storage optimized, compute optimized, and with GPU.

Snowball Edge is the optimal choice if you need to securely and quickly transfer dozens of terabytes to petabytes of data to AWS. The AWS Snow Family is ideal for customers moving large batches of data at once. The AWS Snowball has a typical 5-7 days turnaround time. As each Snowball Edge device can handle 80TB of data, you can order 3 such devices to take care of the data transfer for the given use-case.



![image](https://user-images.githubusercontent.com/36766101/204161023-2cda23dd-9d09-456c-bb81-a5a0ce6b642a.png)

API Gateway creates RESTful APIs that: Are HTTP-based. Enable stateless client-server communication. Implement standard HTTP methods such as GET, POST, PUT, PATCH, and DELETE.
API Gateway creates WebSocket APIs that: Adhere to the WebSocket protocol, which enables stateful, full-duplex communication between client and server. Route incoming messages based on message content.

So API Gateway supports stateless RESTful APIs as well as stateful WebSocket APIs.


![image](https://user-images.githubusercontent.com/36766101/204161368-2b5dfa9d-55ca-481f-aa19-35f24471fea6.png)
Recovery time objective (RTO) and recovery point objective (RPO) are two key metrics to consider when developing a DR plan. RTO represents how many hours it takes you to return to a working state after a disaster.

Automated backups, manual snapshots and Read Replicas are supported across multiple Regions - The automated backup feature of Amazon RDS enables point-in-time recovery for your database instance. Amazon RDS will backup your database and transaction logs and store both for a user-specified retention period. If it’s a Multi-AZ configuration, backups occur on the standby to reduce I/O impact on the primary. Amazon RDS supports Cross-Region Automated Backups. Manual snapshots and Read Replicas are also supported across multiple Regions.

Database snapshots are user-initiated backups of your complete DB instance that serve as full backups. These snapshots can be copied and shared to different Regions and accounts - Database snapshots are manual (user-initiated) backups of your complete DB instance that serve as full backups. They’re stored in Amazon S3 and are retained until you explicitly delete them. These snapshots can be copied and shared to different Regions and accounts. Because DB snapshots include the entire DB instance, including data files and temporary files, the size of the instance affects the amount of time it takes to create the snapshot.


![image](https://user-images.githubusercontent.com/36766101/204162448-ed7f7fba-d646-4476-a56d-a782edabee5b.png)
Create an application that will traverse the S3 bucket, issue a Byte Range Fetch for the first 250 bytes, and store that information in ElasticSearch

Amazon Simple Storage Service (Amazon S3) is an object storage service that offers industry-leading scalability, data availability, security, and performance.

Amazon Elasticsearch Service (Amazon ES) is a managed service that makes it easy to deploy, operate, and scale Elasticsearch clusters in the AWS Cloud. Elasticsearch is a popular open-source search and analytics engine for use cases such as log analytics, real-time application monitoring, and clickstream analysis. With Amazon ES, you get direct access to the Elasticsearch APIs; existing code and applications work seamlessly with the service.Using the Range HTTP header in a GET Object request, you can fetch a byte-range from an object, transferring only the specified portion. You can use concurrent connections to Amazon S3 to fetch different byte ranges from within the same object. This helps you achieve higher aggregate throughput versus a single whole-object request. Fetching smaller ranges of a large object also allows your application to improve retry times when requests are interrupted.
A byte-range request is a perfect way to get the beginning of a file and ensuring we remain efficient during our scan of our S3 bucket. You can then store the relevant information in the form of a JSON document in ElasticSearch.

Create an application that will use the S3 Select ScanRange parameter to get the first 250 bytes and store that information in ElasticSearch
With Amazon S3 Select, you can scan a subset of an object by specifying a range of bytes to query using the ScanRange parameter. This capability lets you parallelize scanning the whole object by splitting the work into separate Amazon S3 Select requests for a series of non-overlapping scan ranges. Use the Amazon S3 Select ScanRange parameter and Start at (Byte) and End at (Byte). You can then store the relevant information in the form of a JSON document in ElasticSearch.



![image](https://user-images.githubusercontent.com/36766101/204162766-90d35fd2-ed85-41ea-b925-007a45bb4302.png)
By default, an S3 object is owned by the AWS account that uploaded it. So the S3 bucket owner will not implicitly have access to the objects written by Redshift cluster - By default, an S3 object is owned by the AWS account that uploaded it. This is true even when the bucket is owned by another account. Because the Amazon Redshift data files from the UNLOAD command were put into your bucket by another account, you (the bucket owner) don't have default permission to access those files.


![image](https://user-images.githubusercontent.com/36766101/204165464-70a482de-1d54-4d40-81a5-f46c49b45842.png)
Develop the leaderboard using ElastiCache Redis as it meets the in-memory, high availability, low latency requirements
Amazon ElastiCache for Redis is a blazing fast in-memory data store that provides sub-millisecond latency to power internet-scale real-time applications. Amazon ElastiCache for Redis is a great choice for real-time transactional and analytical processing use cases such as caching, chat/messaging, gaming leaderboards, geospatial, machine learning, media streaming, queues, real-time analytics, and session store. ElastiCache for Redis can be used to power the live leaderboard, so this option is correct.

Develop the leaderboard using DynamoDB with DynamoDB Accelerator (DAX) as it meets the in-memory, high availability, low latency requirements
Amazon DynamoDB is a key-value and document database that delivers single-digit millisecond performance at any scale. It's a fully managed, multi-Region, multi-master, durable database with built-in security, backup and restore, and in-memory caching for internet-scale applications.
DAX is a DynamoDB-compatible caching service that enables you to benefit from fast in-memory performance for demanding applications. So DynamoDB with DAX can be used to power the live leaderboard.



![image](https://user-images.githubusercontent.com/36766101/204165595-9c8c2202-8155-4b83-914b-236397238be7.png)
VPC sharing (part of Resource Access Manager) allows multiple AWS accounts to create their application resources such as EC2 instances, RDS databases, Redshift clusters, and Lambda functions, into shared and centrally-managed Amazon Virtual Private Clouds (VPCs).

To set this up, the account that owns the VPC (owner) shares one or more subnets with other accounts (participants) that belong to the same organization from AWS Organizations. After a subnet is shared, the participants can view, create, modify, and delete their application resources in the subnets shared with them. Participants cannot view, modify, or delete resources that belong to other participants or the VPC owner.

You can share Amazon VPCs to leverage the implicit routing within a VPC for applications that require a high degree of interconnectivity and are within the same trust boundaries. This reduces the number of VPCs that you create and manage while using separate accounts for billing and access control.




![image](https://user-images.githubusercontent.com/36766101/204165979-b5cf38c7-9a51-4e08-b24c-b2e552d1634b.png)
Dynamic content, as determined at request time (cache-behavior configured to forward all headers), does not flow through regional edge caches, but goes directly to the origin.
Amazon CloudFront is a fast content delivery network (CDN) service that securely delivers data, videos, applications, and APIs to customers globally with low latency, high transfer speeds, all within a developer-friendly environment. CloudFront points of presence (POPs) (edge locations) make sure that popular content can be served quickly to your viewers. CloudFront also has regional edge caches that bring more of your content closer to your viewers, even when the content is not popular enough to stay at a POP, to help improve performance for that content.

Proxy methods PUT/POST/PATCH/OPTIONS/DELETE go directly to the origin
Proxy methods PUT/POST/PATCH/OPTIONS/DELETE go directly to the origin from the POPs and do not proxy through the regional edge caches. So this option is also correct.


![image](https://user-images.githubusercontent.com/36766101/204166498-69f103c9-19f2-4e50-9cc3-8d99e8e33419.png)

Lambda functions always operate from an AWS-owned VPC. By default, your function has full ability to make network requests to any public internet address — this includes access to any of the public AWS APIs. For example, your function can interact with AWS DynamoDB APIs to PutItem or Query for records. You should only enable your functions for VPC access when you need to interact with a private resource located in a private subnet. An RDS instance is a good example.
![image](https://user-images.githubusercontent.com/36766101/204166555-5aaefdff-aa8c-4677-8598-f0b9b0062950.png)
Since Lambda functions can scale extremely quickly, this means you should have controls in place to notify you when you have a spike in concurrency. A good idea is to deploy a CloudWatch Alarm that notifies your team when function metrics such as ConcurrentExecutions or Invocations exceeds your threshold. You should create an AWS Budget so you can monitor costs on a daily basis.
Since Lambda functions can scale extremely quickly, this means you should have controls in place to notify you when you have a spike in concurrency. A good idea is to deploy a CloudWatch Alarm that notifies your team when function metrics such as ConcurrentExecutions or Invocations exceeds your threshold. You should create an AWS Budget so you can monitor costs on a daily basis.



![image](https://user-images.githubusercontent.com/36766101/204167132-3c1ed1db-67b3-4c21-9e2b-9ef4127a49ce.png)
Create a snapshot copy grant in the destination Region for a KMS key in the destination Region. Configure Redshift cross-Region snapshots in the source Region

To copy snapshots for AWS KMS–encrypted clusters to another AWS Region, you need to create a grant for Redshift to use a KMS customer master key (CMK) in the destination AWS Region. Then choose that grant when you enable copying of snapshots in the source AWS Region. You cannot use a KMS key from the source Region as AWS KMS keys are specific to an AWS Region.
![image](https://user-images.githubusercontent.com/36766101/204167193-16354f79-d2f9-470d-9fda-c611a0af4c44.png)


![image](https://user-images.githubusercontent.com/36766101/204167216-72e9b1dd-344c-43fe-bb51-c1a4e761177f.png)
AWS WAF is a web application firewall that helps protect your web applications or APIs against common web exploits that may affect availability, compromise security, or consume excessive resources. AWS WAF gives you control over how traffic reaches your applications by enabling you to create security rules that block common attack patterns and rules that filter out specific traffic patterns you define.

You can deploy AWS WAF on Amazon CloudFront as part of your CDN solution, the Application Load Balancer that fronts your web servers or origin servers running on EC2, or Amazon API Gateway for your APIs.

To block specific countries, you can create a WAF geo match statement listing the countries that you want to block, and to allow traffic from IPs of the remote development team, you can create a WAF IP set statement that specifies the IP addresses that you want to allow through. 


![image](https://user-images.githubusercontent.com/36766101/204167327-d26369b1-f0bf-44d0-a38d-d170c3f8f92c.png)
Set up Kinesis Data Firehose in the logging account and then subscribe the delivery stream to CloudWatch Logs streams in each application AWS account via subscription filters. Persist the log data in an Amazon S3 bucket inside the logging AWS account

You can configure Amazon Kinesis Data Firehose to aggregate and collate CloudWatch Logs from different AWS accounts and receive their log events in a centralized logging AWS Account (this is known as cross-account data sharing) by using a CloudWatch Logs destination and then creating a Subscription Filter. This log event data can be read from a centralized Amazon Kinesis Firehose delivery stream to perform downstream processing and analysis.

You can collaborate with an owner of a different AWS account and receive their log events on your AWS resources, such as an Amazon Kinesis or Amazon Kinesis Data Firehose stream (this is known as cross-account data sharing). You can use a subscription filter with Kinesis Streams, Lambda, or Kinesis Data Firehose. Logs that are sent to a receiving service through a subscription filter are Base64 encoded and compressed with the gzip format.


![image](https://user-images.githubusercontent.com/36766101/204167398-f8a49d00-c1d5-47a9-81ba-0ae5cb7c2b3e.png)
Set up DynamoDB Streams to capture and send updates to a Lambda function that outputs records to Kinesis Data Analytics (KDA) via Kinesis Data Streams (KDS). Detect and analyze anomalies in KDA and send notifications via SNS

A DynamoDB stream is an ordered flow of information about changes to items in a DynamoDB table. When you enable a stream on a table, DynamoDB captures information about every modification to data items in the table for up to 24 hours.

Whenever an application creates, updates, or deletes items in the table, DynamoDB Streams writes a stream record with the primary key attributes of the items that were modified. A stream record contains information about a data modification to a single item in a DynamoDB table.

DynamoDB Streams supports the following stream record views:

KEYS_ONLY — Only the key attributes of the modified item NEW_IMAGE — The entire item, as it appears after it was modified OLD_IMAGE — The entire item, as it appears before it was modified NEW_AND_OLD_IMAGES — Both the new and the old images of the item

You can process DynamoDB streams in multiple ways. The most common approaches use AWS Lambda or a standalone application that uses the Kinesis Client Library (KCL) with the DynamoDB Streams Kinesis Adapter. The KCL is a client-side library that provides an interface to process DynamoDB stream changes. If you enable DynamoDB Streams on a table, you can associate the stream Amazon Resource Name (ARN) with an AWS Lambda function that you write. Immediately after an item in the table is modified, a new record appears in the table's stream. AWS Lambda polls the stream and invokes your Lambda function synchronously when it detects new stream records.
![image](https://user-images.githubusercontent.com/36766101/204167547-bf4d04db-7d61-43d9-964e-cd99920f8d66.png)
For the given use-case, you can use a Lambda function to capture updates from DynamoDB Streams and send those records to KDA via KDS. You can then detect and analyze anomalies in KDA and send notifications via SNS.
![image](https://user-images.githubusercontent.com/36766101/204167675-caedd8c9-f016-473f-978a-3539eacc4d89.png)

It is important to note that Kinesis Data Analytics (KDA) only supports the following streaming sources for an application:
A Kinesis data stream (KDS)
A Kinesis Data Firehose (KDF) delivery stream
Therefore, you cannot directly write the output of the records from a Lambda function to KDA, although you can certainly use a Lambda function to pre-process the incoming stream from either KDS or KDF.


![image](https://user-images.githubusercontent.com/36766101/204167906-5be59dbe-8fe1-4fdf-a21b-8789b95e0849.png)
AWS DataSync is an online data transfer service that simplifies, automates, and accelerates copying large amounts of data to and from AWS storage services over the internet or AWS Direct Connect. AWS DataSync fully automates and accelerates moving large active datasets to AWS, up to 10 times faster than command-line tools. It is natively integrated with Amazon S3, Amazon EFS, Amazon FSx for Windows File Server, Amazon CloudWatch, and AWS CloudTrail, which provides seamless and secure access to your storage services, as well as detailed monitoring of the transfer.

DataSync uses a purpose-built network protocol and scale-out architecture to transfer data. A single DataSync agent is capable of saturating a 10 Gbps network link. DataSync fully automates the data transfer. It comes with retry and network resiliency mechanisms, network optimizations, built-in task scheduling, monitoring via the DataSync API and Console, and CloudWatch metrics, events, and logs that provide granular visibility into the transfer process. DataSync performs data integrity verification both during the transfer and at AWS Storage Gateway is a hybrid cloud storage service that gives you on-premises access to virtually unlimited cloud storage. The service provides three different types of gateways – Tape Gateway, File Gateway, and Volume Gateway – that seamlessly connect on-premises applications to cloud storage, caching data locally for low-latency access. File gateway offers SMB or NFS-based access to data in Amazon S3 with local caching.

The combination of DataSync and File Gateway is the correct solution. AWS DataSync enables you to automate and accelerate online data transfers to AWS storage services. File Gateway then provides your on-premises applications with low latency access to the migrated data.the end of the transfer.
![image](https://user-images.githubusercontent.com/36766101/204168003-d6a41bfe-ff6b-413b-9a1f-db49a243da48.png)
![image](https://user-images.githubusercontent.com/36766101/204168028-fcb663ec-71d4-4b64-9dbc-43fb75a6bc19.png)


AWS Storage Gateway is a hybrid cloud storage service that gives you on-premises access to virtually unlimited cloud storage. The service provides three different types of gateways – Tape Gateway, File Gateway, and Volume Gateway – that seamlessly connect on-premises applications to cloud storage, caching data locally for low-latency access. File gateway offers SMB or NFS-based access to data in Amazon S3 with local caching.

The combination of DataSync and File Gateway is the correct solution. AWS DataSync enables you to automate and accelerate online data transfers to AWS storage services. File Gateway then provides your on-premises applications with low latency access to the migrated data.



![image](https://user-images.githubusercontent.com/36766101/204168218-a3b527f9-4a05-4f7e-9805-11013ca31064.png)

Create separate cache behaviors for static and dynamic content. Remove the Date HTTP header from the whitelist headers section on both of the cache behaviors. Remove the session cookie from the whitelist cookies section for static content as well as the Authorization HTTP header from the whitelist headers section for cache behavior configured for static content




<img width="761" alt="image" src="https://github.com/user-attachments/assets/60327e40-08d9-49e3-9eff-243754b9a8e2">







An e-commerce company wants to rollout and test a blue-green deployment for its global application in the next couple of days. Most of the customers use mobile phones which are prone to DNS caching. The company has only two days left before the big sale will be launched.
As a Solutions Architect Professional, which of the following options would you suggest to test the deployment on as many users as possible in the given time frame?




A Use Route 53 weighted routing to spread traffic across different deployments



B Use AWS Global Accelerator to distribute a portion of traffic to a particular deployment

<img width="628" alt="image" src="https://github.com/user-attachments/assets/b1ee9a22-4fba-43e6-b22c-739be2d927c5">
<img width="758" alt="image" src="https://github.com/user-attachments/assets/b7da8b78-1f33-4558-877f-c4b18dc79a5f">



CloudFront is a web service that speeds up the distribution of your static and dynamic web content by routing each user request through the AWS backbone network to the edge location that can best serve your content.

One of the purposes of using CloudFront is to reduce the number of requests that your origin server must respond to directly. With CloudFront caching, more objects are served from CloudFront edge locations, which are closer to your users. This reduces the load on your origin server and reduces latency. The proportion of requests that are served from caches to all requests is called the cache hit ratio.

To improve the cache hit ratio when CloudFront is configured to cache based on cookie values you should create separate cache behaviors for static and dynamic content, and configure CloudFront to forward cookies to your origin only for dynamic content. So, for the given use-case, you should remove the session cookie from the whitelist cookies section for static content.

To improve the cache hit ratio when CloudFront is configured to cache based on request headers, you should set up CloudFront to forward and cache based on only specified headers instead of forwarding and caching based on all headers. So, you can remove Authorization HTTP header from the whitelist headers section for cache behavior configured for static content. In addition, AWS recommends not to configure caching based on values in the Date and User-Agent headers, because these headers have numerous possible values and caching based on their values could cause CloudFront to forward significantly more requests to your origin.


![image](https://user-images.githubusercontent.com/36766101/204168763-11e1ca54-c926-4fb5-80b8-3970182ef41b.png)
Amazon Simple Queue Service (SQS) is a fully managed message queuing service that enables you to decouple and scale microservices, distributed systems, and serverless applications. SQS offers two types of message queues - Standard queues vs FIFO queues.

For FIFO queues, the order in which messages are sent and received is strictly preserved (i.e. First-In-First-Out). On the other hand, the standard SQS queues offer best-effort ordering. This means that occasionally, messages might be delivered in an order different from which they were sent.

By default, FIFO queues support up to 300 transactions (API calls) per second (300 send, receive, or delete operations per second). When you batch 10 transactions per operation (maximum), FIFO queues can support up to 3,000 (30010) transactions per second. Therefore, you need to process 8 transactions per operation so that the FIFO queue can support up to 2,400 (3008) transactions per second, which satisfies the peak rate constraint.



![image](https://user-images.githubusercontent.com/36766101/204169192-d6c9b9ef-a47d-4706-afc1-713e8eaecae9.png)

![image](https://user-images.githubusercontent.com/36766101/204169388-b9b1c563-7df6-4679-86a9-2c2b5cc18b98.png)


![image](https://user-images.githubusercontent.com/36766101/204170428-36e82478-ec2f-4183-b10f-b6abd8feaf51.png)

![image](https://user-images.githubusercontent.com/36766101/204170912-fcc0fd8c-5094-49d6-9be3-93fe382d157f.png)


![image](https://user-images.githubusercontent.com/36766101/204169311-07116b7a-1837-4e87-aae0-306222da1938.png)



![image](https://user-images.githubusercontent.com/36766101/204171116-ec1d98f3-6944-4c48-a85e-2639b6bd3ca8.png)
Amazon S3 Transfer Acceleration enables fast, easy, and secure transfers of files over long distances between your client and an S3 bucket. Transfer Acceleration takes advantage of Amazon CloudFront’s globally distributed edge locations. As the data arrives at an edge location, data is routed to Amazon S3 over an optimized network path.
Use multipart uploads for faster file uploads into the destination S3 bucket - Multipart upload allows you to upload a single object as a set of parts. Each part is a contiguous portion of the object's data. You can upload these object parts independently and in any order. If transmission of any part fails, you can retransmit that part without affecting other parts. After all parts of your object are uploaded, Amazon S3 assembles these parts and creates the object. In general, when your object size reaches 100 MB, you should consider using multipart uploads instead of uploading the object in a single operation. Multipart upload provides improved throughput, therefore it facilitates faster file uploads.

![image](https://user-images.githubusercontent.com/36766101/204171453-4b809ee0-4a8c-4441-ae9f-d6162149efbb.png)
Amazon Kinesis Data Streams (KDS) is a massively scalable and durable real-time data streaming service. KDS can continuously capture gigabytes of data per second from hundreds of thousands of sources such as website clickstreams, database event streams, financial transactions, social media feeds, IT logs, and location-tracking events. By default, the 2MB/second/shard output is shared between all of the applications consuming data from the stream.

You should use enhanced fan-out if you have multiple consumers retrieving data from a stream in parallel. With enhanced fan-out developers can register stream consumers to use enhanced fan-out and receive their own 2MB/second pipe of read throughput per shard, and this throughput automatically scales with the number of shards in a stream.
![image](https://user-images.githubusercontent.com/36766101/204171628-0722fb56-ce28-433a-a9b0-3be80b85c57c.png)



![image](https://user-images.githubusercontent.com/36766101/204176129-bc0d9710-ca97-42cf-a4d1-2d21199be3de.png)





<img width="754" alt="image" src="https://github.com/user-attachments/assets/83fed198-698a-4238-8c5e-524a58f100af">





<img width="765" alt="image" src="https://github.com/user-attachments/assets/aebde5ce-bfad-4d3f-9679-106c9c64cd15">

<img width="758" alt="image" src="https://github.com/user-attachments/assets/3232deba-2108-4f27-bc47-edd3032a3000">

<img width="757" alt="image" src="https://github.com/user-attachments/assets/3f4c531b-3edb-4dab-bbba-6fdae05fd70e">


<img width="772" alt="image" src="https://github.com/user-attachments/assets/82dcba8d-40af-4bbb-b7f7-c73f04ae0b91">


<img width="765" alt="image" src="https://github.com/user-attachments/assets/7eb9f0e1-06a4-40a1-833a-d20f06fc5c93">



<img width="765" alt="image" src="https://github.com/user-attachments/assets/fd1b5592-6ea8-430d-8953-9a83fe15444b">

<img width="777" alt="image" src="https://github.com/user-attachments/assets/60765fb3-097c-45ff-807a-010d545d2176">

<img width="760" alt="image" src="https://github.com/user-attachments/assets/165892f0-82c8-4fd9-97b7-537415c4b941">


<img width="770" alt="image" src="https://github.com/user-attachments/assets/fb427957-9d23-4ffe-9839-065b0dfacb02">


<img width="773" alt="image" src="https://github.com/user-attachments/assets/7b3af3f4-cbb6-41d8-a9d1-5f86e5d3da3c">


<img width="765" alt="image" src="https://github.com/user-attachments/assets/602ff73e-4cf9-4d71-99b3-0fb176aad996">
<img width="607" alt="image" src="https://github.com/user-attachments/assets/23e87e75-3fd8-4313-94c8-f477e312cbd7">




<img width="762" alt="image" src="https://github.com/user-attachments/assets/9662d1ef-04ca-41db-af2a-365b2b18bdb4">

<img width="747" alt="image" src="https://github.com/user-attachments/assets/fbf9705a-fab3-4ae4-9c48-35cd6932eb3d">

<img width="764" alt="image" src="https://github.com/user-attachments/assets/20840df1-c520-4237-b954-dc9f3f8fbb56">


<img width="766" alt="image" src="https://github.com/user-attachments/assets/4acde22f-4c73-4597-90f3-ed3072889c7a">

<img width="763" alt="image" src="https://github.com/user-attachments/assets/ec089e33-8ae0-4317-999b-71f788e2b1dd">

